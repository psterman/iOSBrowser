//
//  iOSBrowserWidgets.swift
//  iOSBrowserWidgets
//
//  å…¨æ–°å°ç»„ä»¶ç³»ç»Ÿ v2025-07-31
//  åŸºäºå°ç»„ä»¶é…ç½®tabçš„å››ä¸ªæ ‡ç­¾é‡æ–°æ„å»º
//

import WidgetKit
import SwiftUI

// MARK: - å°ç»„ä»¶åŒ…å…¥å£
@main
struct iOSBrowserWidgetBundle: WidgetBundle {
    var body: some Widget {
        SearchEngineWidget()
        AppSelectionWidget()
        AIAssistantWidget()
        QuickActionWidget()
    }
}

// MARK: - æ•°æ®ç®¡ç†å™¨
class WidgetDataManager {
    static let shared = WidgetDataManager()

    private init() {}

    // App Groups UserDefaults - ä¸»è¦æ•°æ®æº
    private let sharedDefaults = UserDefaults(suiteName: "group.com.iosbrowser.shared")
    // æ ‡å‡†UserDefaults - å¤‡ç”¨æ•°æ®æº
    private let standardDefaults = UserDefaults.standard

    // MARK: - ç»Ÿä¸€æ•°æ®è¯»å–æ–¹æ³•
    private func readStringArray(primaryKey: String, fallbackKeys: [String] = [], defaultValue: [String] = []) -> [String] {
        print("ğŸ” [WidgetDataManager] è¯»å–æ•°æ®: \(primaryKey)")
        print("ğŸ” [WidgetDataManager] å¤‡ç”¨é”®: \(fallbackKeys)")

        // å¼ºåˆ¶åŒæ­¥
        let stdSync = standardDefaults.synchronize()
        print("ğŸ” [WidgetDataManager] UserDefaultsåŒæ­¥: \(stdSync)")

        let sharedSync = sharedDefaults?.synchronize() ?? false
        print("ğŸ” [WidgetDataManager] App GroupsåŒæ­¥: \(sharedSync)")

        // 1. ä¼˜å…ˆä»App Groupsè¯»å–
        if let shared = sharedDefaults {
            print("ğŸ” [App Groups] UserDefaultså¯¹è±¡åˆ›å»ºæˆåŠŸ")
            let data = shared.stringArray(forKey: primaryKey) ?? []
            print("ğŸ” [App Groups] è¯»å–ç»“æœ: \(primaryKey) = \(data)")
            if !data.isEmpty {
                print("âœ… [App Groups] è¯»å–æˆåŠŸ: \(primaryKey) = \(data)")
                return data
            } else {
                print("âš ï¸ [App Groups] æ•°æ®ä¸ºç©º: \(primaryKey)")
            }
        } else {
            print("âŒ [App Groups] UserDefaultså¯¹è±¡åˆ›å»ºå¤±è´¥")
        }

        // 2. ä»æ ‡å‡†UserDefaultsè¯»å–ä¸»é”®
        print("ğŸ” [UserDefaults] å°è¯•è¯»å–ä¸»é”®: \(primaryKey)")
        let mainData = standardDefaults.stringArray(forKey: primaryKey) ?? []
        print("ğŸ” [UserDefaults] ä¸»é”®è¯»å–ç»“æœ: \(primaryKey) = \(mainData)")
        if !mainData.isEmpty {
            print("âœ… [UserDefaults] è¯»å–æˆåŠŸ: \(primaryKey) = \(mainData)")
            return mainData
        } else {
            print("âš ï¸ [UserDefaults] ä¸»é”®æ•°æ®ä¸ºç©º: \(primaryKey)")
        }

        // 3. å°è¯•å¤‡ç”¨é”®
        print("ğŸ” [UserDefaults] å°è¯•å¤‡ç”¨é”®: \(fallbackKeys)")
        for key in fallbackKeys {
            print("ğŸ” [UserDefaults] å°è¯•å¤‡ç”¨é”®: \(key)")
            let fallbackData = standardDefaults.stringArray(forKey: key) ?? []
            print("ğŸ” [UserDefaults] å¤‡ç”¨é”®è¯»å–ç»“æœ: \(key) = \(fallbackData)")
            if !fallbackData.isEmpty {
                print("âœ… [å¤‡ç”¨é”®] è¯»å–æˆåŠŸ: \(key) = \(fallbackData)")
                return fallbackData
            } else {
                print("âš ï¸ [å¤‡ç”¨é”®] æ•°æ®ä¸ºç©º: \(key)")
            }
        }

        print("âš ï¸ [é»˜è®¤å€¼] æ‰€æœ‰æ•°æ®æºéƒ½ä¸ºç©ºï¼Œä½¿ç”¨é»˜è®¤å€¼: \(defaultValue)")
        return defaultValue
    }

    // MARK: - å››ä¸ªæ ‡ç­¾çš„æ•°æ®è¯»å–æ–¹æ³•

    // 1. æœç´¢å¼•æ“æ•°æ® - æ¸…ç©ºé»˜è®¤å€¼ç”¨äºæµ‹è¯•
    func getSearchEngines() -> [String] {
        let result = readStringArray(
            primaryKey: "widget_search_engines",
            fallbackKeys: ["iosbrowser_engines", "widget_search_engines_v2"],
            defaultValue: []  // ğŸ”¥ æ¸…ç©ºé»˜è®¤å€¼
        )
        print("ğŸ” [getSearchEngines] æœ€ç»ˆè¿”å›: \(result)")
        return result
    }

    // 2. åº”ç”¨æ•°æ® - æ¸…ç©ºé»˜è®¤å€¼ç”¨äºæµ‹è¯•
    func getApps() -> [String] {
        let result = readStringArray(
            primaryKey: "widget_apps",
            fallbackKeys: ["iosbrowser_apps", "widget_apps_v2"],
            defaultValue: []  // ğŸ”¥ æ¸…ç©ºé»˜è®¤å€¼
        )
        print("ğŸ” [getApps] æœ€ç»ˆè¿”å›: \(result)")
        return result
    }

    // 3. AIåŠ©æ‰‹æ•°æ® - æ¸…ç©ºé»˜è®¤å€¼ç”¨äºæµ‹è¯•
    func getAIAssistants() -> [String] {
        let result = readStringArray(
            primaryKey: "widget_ai_assistants",
            fallbackKeys: ["iosbrowser_ai", "widget_ai_assistants_v2"],
            defaultValue: []  // ğŸ”¥ æ¸…ç©ºé»˜è®¤å€¼
        )
        print("ğŸ” [getAIAssistants] æœ€ç»ˆè¿”å›: \(result)")
        return result
    }

    // 4. å¿«æ·æ“ä½œæ•°æ® - æ¸…ç©ºé»˜è®¤å€¼ç”¨äºæµ‹è¯•
    func getQuickActions() -> [String] {
        let result = readStringArray(
            primaryKey: "widget_quick_actions",
            fallbackKeys: ["iosbrowser_actions", "widget_quick_actions_v2"],
            defaultValue: []  // ğŸ”¥ æ¸…ç©ºé»˜è®¤å€¼
        )
        print("ğŸ” [getQuickActions] æœ€ç»ˆè¿”å›: \(result)")
        return result
    }
}

// MARK: - æ•°æ®æ¨¡å‹

// æœç´¢å¼•æ“æ¡ç›®
struct SearchEngineEntry: TimelineEntry {
    let date: Date
    let engines: [String]
}

// åº”ç”¨æ¡ç›®
struct AppEntry: TimelineEntry {
    let date: Date
    let apps: [String]
}

// AIåŠ©æ‰‹æ¡ç›®
struct AIEntry: TimelineEntry {
    let date: Date
    let assistants: [String]
}

// å¿«æ·æ“ä½œæ¡ç›®
struct QuickActionEntry: TimelineEntry {
    let date: Date
    let actions: [String]
}

// MARK: - Timeline Providers

// 1. æœç´¢å¼•æ“ Timeline Provider
struct SearchEngineProvider: TimelineProvider {
    func placeholder(in context: Context) -> SearchEngineEntry {
        SearchEngineEntry(date: Date(), engines: WidgetDataManager.shared.getSearchEngines())
    }

    func getSnapshot(in context: Context, completion: @escaping (SearchEngineEntry) -> ()) {
        let entry = SearchEngineEntry(date: Date(), engines: WidgetDataManager.shared.getSearchEngines())
        completion(entry)
    }

    func getTimeline(in context: Context, completion: @escaping (Timeline<SearchEngineEntry>) -> ()) {
        print("ğŸ”„ [SearchEngineProvider] getTimeline è¢«è°ƒç”¨")

        let engines = WidgetDataManager.shared.getSearchEngines()
        let entry = SearchEngineEntry(date: Date(), engines: engines)

        print("ğŸ”„ [SearchEngineProvider] è·å–çš„æœç´¢å¼•æ“: \(engines)")

        // æ¯5åˆ†é’Ÿæ›´æ–°ä¸€æ¬¡
        let nextUpdate = Calendar.current.date(byAdding: .minute, value: 5, to: Date())!
        let timeline = Timeline(entries: [entry], policy: .after(nextUpdate))
        completion(timeline)
    }
}

// 2. åº”ç”¨ Timeline Provider
struct AppProvider: TimelineProvider {
    func placeholder(in context: Context) -> AppEntry {
        AppEntry(date: Date(), apps: WidgetDataManager.shared.getApps())
    }

    func getSnapshot(in context: Context, completion: @escaping (AppEntry) -> ()) {
        let entry = AppEntry(date: Date(), apps: WidgetDataManager.shared.getApps())
        completion(entry)
    }

    func getTimeline(in context: Context, completion: @escaping (Timeline<AppEntry>) -> ()) {
        print("ğŸ”„ [AppProvider] getTimeline è¢«è°ƒç”¨")

        let apps = WidgetDataManager.shared.getApps()
        let entry = AppEntry(date: Date(), apps: apps)

        print("ğŸ”„ [AppProvider] è·å–çš„åº”ç”¨: \(apps)")

        let nextUpdate = Calendar.current.date(byAdding: .minute, value: 5, to: Date())!
        let timeline = Timeline(entries: [entry], policy: .after(nextUpdate))
        completion(timeline)
    }
}

// 3. AIåŠ©æ‰‹ Timeline Provider
struct AIProvider: TimelineProvider {
    func placeholder(in context: Context) -> AIEntry {
        AIEntry(date: Date(), assistants: WidgetDataManager.shared.getAIAssistants())
    }

    func getSnapshot(in context: Context, completion: @escaping (AIEntry) -> ()) {
        let entry = AIEntry(date: Date(), assistants: WidgetDataManager.shared.getAIAssistants())
        completion(entry)
    }

    func getTimeline(in context: Context, completion: @escaping (Timeline<AIEntry>) -> ()) {
        print("ğŸ”„ [AIProvider] getTimeline è¢«è°ƒç”¨")

        let assistants = WidgetDataManager.shared.getAIAssistants()
        let entry = AIEntry(date: Date(), assistants: assistants)

        print("ğŸ”„ [AIProvider] è·å–çš„AIåŠ©æ‰‹: \(assistants)")

        let nextUpdate = Calendar.current.date(byAdding: .minute, value: 5, to: Date())!
        let timeline = Timeline(entries: [entry], policy: .after(nextUpdate))
        completion(timeline)
    }
}

// 4. å¿«æ·æ“ä½œ Timeline Provider
struct QuickActionProvider: TimelineProvider {
    func placeholder(in context: Context) -> QuickActionEntry {
        QuickActionEntry(date: Date(), actions: WidgetDataManager.shared.getQuickActions())
    }

    func getSnapshot(in context: Context, completion: @escaping (QuickActionEntry) -> ()) {
        let entry = QuickActionEntry(date: Date(), actions: WidgetDataManager.shared.getQuickActions())
        completion(entry)
    }

    func getTimeline(in context: Context, completion: @escaping (Timeline<QuickActionEntry>) -> ()) {
        print("ğŸ”„ [QuickActionProvider] getTimeline è¢«è°ƒç”¨")

        let actions = WidgetDataManager.shared.getQuickActions()
        let entry = QuickActionEntry(date: Date(), actions: actions)

        print("ğŸ”„ [QuickActionProvider] è·å–çš„å¿«æ·æ“ä½œ: \(actions)")

        let nextUpdate = Calendar.current.date(byAdding: .minute, value: 5, to: Date())!
        let timeline = Timeline(entries: [entry], policy: .after(nextUpdate))
        completion(timeline)
    }
}

// MARK: - å·¥å…·å‡½æ•°

// è·å–æœç´¢å¼•æ“ä¿¡æ¯
func getSearchEngineInfo(_ engineId: String) -> (name: String, color: Color, icon: String) {
    switch engineId {
    case "baidu": return ("ç™¾åº¦", .red, "magnifyingglass")
    case "google": return ("Google", .blue, "globe")
    case "bing": return ("Bing", .blue, "magnifyingglass.circle")
    case "yahoo": return ("Yahoo", .purple, "y.circle")
    case "duckduckgo": return ("DuckDuckGo", .orange, "shield")
    case "yandex": return ("Yandex", .red, "y.square")
    case "sogou": return ("æœç‹—", .blue, "s.circle")
    default: return (engineId, .gray, "questionmark.circle")
    }
}

// è·å–åº”ç”¨ä¿¡æ¯
func getAppInfo(_ appId: String) -> (name: String, color: Color, icon: String) {
    switch appId {
    case "taobao": return ("æ·˜å®", .orange, "bag")
    case "zhihu": return ("çŸ¥ä¹", .blue, "questionmark.circle")
    case "douyin": return ("æŠ–éŸ³", .black, "music.note")
    case "wechat": return ("å¾®ä¿¡", .green, "message")
    case "alipay": return ("æ”¯ä»˜å®", .blue, "creditcard")
    case "meituan": return ("ç¾å›¢", .yellow, "fork.knife")
    case "didi": return ("æ»´æ»´", .orange, "car")
    default: return (appId, .gray, "app")
    }
}

// è·å–AIåŠ©æ‰‹ä¿¡æ¯
func getAIInfo(_ aiId: String) -> (name: String, color: Color, icon: String) {
    switch aiId {
    case "deepseek": return ("DeepSeek", .blue, "brain")
    case "qwen": return ("é€šä¹‰åƒé—®", .purple, "bubble.left")
    case "chatgpt": return ("ChatGPT", .green, "message.circle")
    case "claude": return ("Claude", .orange, "person.circle")
    case "gemini": return ("Gemini", .blue, "star.circle")
    case "copilot": return ("Copilot", .indigo, "airplane.circle")
    default: return (aiId, .gray, "questionmark.circle")
    }
}

// è·å–å¿«æ·æ“ä½œä¿¡æ¯
func getActionInfo(_ actionId: String) -> (name: String, color: Color, icon: String) {
    switch actionId {
    case "search": return ("æœç´¢", .blue, "magnifyingglass")
    case "bookmark": return ("ä¹¦ç­¾", .orange, "bookmark")
    case "translate": return ("ç¿»è¯‘", .green, "textformat")
    case "calculator": return ("è®¡ç®—å™¨", .red, "plus.forwardslash.minus")
    case "weather": return ("å¤©æ°”", .cyan, "cloud.sun")
    case "timer": return ("è®¡æ—¶å™¨", .purple, "timer")
    default: return (actionId, .gray, "gear")
    }
}

// MARK: - å°ç»„ä»¶è§†å›¾

// 1. æœç´¢å¼•æ“å°ç»„ä»¶è§†å›¾
struct SearchEngineWidgetView: View {
    let entry: SearchEngineEntry

    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Image(systemName: "magnifyingglass")
                    .foregroundColor(.blue)
                Text("æœç´¢å¼•æ“")
                    .font(.caption)
                    .fontWeight(.medium)
                Spacer()
            }

            if entry.engines.isEmpty {
                // æ˜¾ç¤ºæ— æ•°æ®çŠ¶æ€
                VStack(spacing: 4) {
                    Image(systemName: "exclamationmark.triangle")
                        .foregroundColor(.orange)
                        .font(.system(size: 24))
                    Text("æ— æ•°æ®")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("è¯·åœ¨ä¸»åº”ç”¨ä¸­é…ç½®")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 2), spacing: 6) {
                    ForEach(Array(entry.engines.prefix(4).enumerated()), id: \.offset) { index, engineId in
                        let info = getSearchEngineInfo(engineId)

                        VStack(spacing: 2) {
                            Image(systemName: info.icon)
                                .foregroundColor(info.color)
                                .font(.system(size: 16))
                            Text(info.name)
                                .font(.caption2)
                                .lineLimit(1)
                        }
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 4)
                        .background(Color(.systemGray6))
                        .cornerRadius(6)
                    }
                }
            }
        }
        .padding()
        .background(Color(.systemBackground))
    }
}

// 2. åº”ç”¨å°ç»„ä»¶è§†å›¾
struct AppWidgetView: View {
    let entry: AppEntry

    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Image(systemName: "app")
                    .foregroundColor(.green)
                Text("åº”ç”¨")
                    .font(.caption)
                    .fontWeight(.medium)
                Spacer()
            }

            if entry.apps.isEmpty {
                // æ˜¾ç¤ºæ— æ•°æ®çŠ¶æ€
                VStack(spacing: 4) {
                    Image(systemName: "exclamationmark.triangle")
                        .foregroundColor(.orange)
                        .font(.system(size: 24))
                    Text("æ— æ•°æ®")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("è¯·åœ¨ä¸»åº”ç”¨ä¸­é…ç½®")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 2), spacing: 6) {
                    ForEach(Array(entry.apps.prefix(4).enumerated()), id: \.offset) { index, appId in
                        let info = getAppInfo(appId)

                        VStack(spacing: 2) {
                            Image(systemName: info.icon)
                                .foregroundColor(info.color)
                                .font(.system(size: 16))
                            Text(info.name)
                                .font(.caption2)
                                .lineLimit(1)
                        }
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 4)
                        .background(Color(.systemGray6))
                        .cornerRadius(6)
                    }
                }
            }
        }
        .padding()
        .background(Color(.systemBackground))
    }
}

// 3. AIåŠ©æ‰‹å°ç»„ä»¶è§†å›¾
struct AIWidgetView: View {
    let entry: AIEntry

    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Image(systemName: "brain")
                    .foregroundColor(.purple)
                Text("AIåŠ©æ‰‹")
                    .font(.caption)
                    .fontWeight(.medium)
                Spacer()
            }

            if entry.assistants.isEmpty {
                // æ˜¾ç¤ºæ— æ•°æ®çŠ¶æ€
                VStack(spacing: 4) {
                    Image(systemName: "exclamationmark.triangle")
                        .foregroundColor(.orange)
                        .font(.system(size: 24))
                    Text("æ— æ•°æ®")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("è¯·åœ¨ä¸»åº”ç”¨ä¸­é…ç½®")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 2), spacing: 6) {
                    ForEach(Array(entry.assistants.prefix(4).enumerated()), id: \.offset) { index, aiId in
                        let info = getAIInfo(aiId)

                        VStack(spacing: 2) {
                            Image(systemName: info.icon)
                                .foregroundColor(info.color)
                                .font(.system(size: 16))
                            Text(info.name)
                                .font(.caption2)
                                .lineLimit(1)
                        }
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 4)
                        .background(Color(.systemGray6))
                        .cornerRadius(6)
                    }
                }
            }
        }
        .padding()
        .background(Color(.systemBackground))
    }
}

// 4. å¿«æ·æ“ä½œå°ç»„ä»¶è§†å›¾
struct QuickActionWidgetView: View {
    let entry: QuickActionEntry

    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Image(systemName: "bolt")
                    .foregroundColor(.orange)
                Text("å¿«æ·æ“ä½œ")
                    .font(.caption)
                    .fontWeight(.medium)
                Spacer()
            }

            if entry.actions.isEmpty {
                // æ˜¾ç¤ºæ— æ•°æ®çŠ¶æ€
                VStack(spacing: 4) {
                    Image(systemName: "exclamationmark.triangle")
                        .foregroundColor(.orange)
                        .font(.system(size: 24))
                    Text("æ— æ•°æ®")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("è¯·åœ¨ä¸»åº”ç”¨ä¸­é…ç½®")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 2), spacing: 6) {
                    ForEach(Array(entry.actions.prefix(4).enumerated()), id: \.offset) { index, actionId in
                        let info = getActionInfo(actionId)

                        VStack(spacing: 2) {
                            Image(systemName: info.icon)
                                .foregroundColor(info.color)
                                .font(.system(size: 16))
                            Text(info.name)
                                .font(.caption2)
                                .lineLimit(1)
                        }
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 4)
                        .background(Color(.systemGray6))
                        .cornerRadius(6)
                    }
                }
            }
        }
        .padding()
        .background(Color(.systemBackground))
    }
}

// MARK: - å°ç»„ä»¶é…ç½®

// 1. æœç´¢å¼•æ“å°ç»„ä»¶
struct SearchEngineWidget: Widget {
    let kind: String = "SearchEngineWidget"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: SearchEngineProvider()) { entry in
            SearchEngineWidgetView(entry: entry)
        }
        .configurationDisplayName("æœç´¢å¼•æ“")
        .description("æ˜¾ç¤ºæ‚¨é…ç½®çš„æœç´¢å¼•æ“")
        .supportedFamilies([.systemSmall, .systemMedium])
    }
}

// 2. åº”ç”¨å°ç»„ä»¶
struct AppSelectionWidget: Widget {
    let kind: String = "AppSelectionWidget"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: AppProvider()) { entry in
            AppWidgetView(entry: entry)
        }
        .configurationDisplayName("åº”ç”¨")
        .description("æ˜¾ç¤ºæ‚¨é…ç½®çš„åº”ç”¨")
        .supportedFamilies([.systemSmall, .systemMedium])
    }
}

// 3. AIåŠ©æ‰‹å°ç»„ä»¶
struct AIAssistantWidget: Widget {
    let kind: String = "AIAssistantWidget"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: AIProvider()) { entry in
            AIWidgetView(entry: entry)
        }
        .configurationDisplayName("AIåŠ©æ‰‹")
        .description("æ˜¾ç¤ºæ‚¨é…ç½®çš„AIåŠ©æ‰‹")
        .supportedFamilies([.systemSmall, .systemMedium])
    }
}

// 4. å¿«æ·æ“ä½œå°ç»„ä»¶
struct QuickActionWidget: Widget {
    let kind: String = "QuickActionWidget"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: QuickActionProvider()) { entry in
            QuickActionWidgetView(entry: entry)
        }
        .configurationDisplayName("å¿«æ·æ“ä½œ")
        .description("æ˜¾ç¤ºæ‚¨é…ç½®çš„å¿«æ·æ“ä½œ")
        .supportedFamilies([.systemSmall, .systemMedium])
    }
}