//
//  AIChatManager.swift
//  iOSBrowser
//
//  AI对话管理器 - 管理AI对话和历史记录
//

import SwiftUI
import Foundation

// MARK: - AI对话消息
struct AIChatMessage: Identifiable, Codable {
    let id = UUID()
    let content: String
    let isUser: Bool
    let timestamp: Date
    let aiService: String
    var isStreaming: Bool = false // 新增：流式状态
}

// MARK: - AI对话会话
struct AIChatSession: Identifiable, Codable {
    let id = UUID()
    let aiService: String
    let title: String
    let messages: [AIChatMessage]
    let createdAt: Date
    let lastUpdated: Date
}

// MARK: - AI对话管理器
class AIChatManager: ObservableObject {
    static let shared = AIChatManager()
    
    @Published var currentSession: AIChatSession?
    @Published var chatSessions: [AIChatSession] = []
    @Published var isChatActive = false
    @Published var isLoading = false
    
    private let userDefaults = UserDefaults.standard
    private let chatSessionsKey = "AIChatSessions"
    
    init() {
        loadChatSessions()
    }
    
    // MARK: - 会话管理
    
    func startNewChat(with aiService: AIService) {
        let newSession = AIChatSession(
            aiService: aiService.id,
            title: "与 \(aiService.name) 的对话",
            messages: [],
            createdAt: Date(),
            lastUpdated: Date()
        )
        
        currentSession = newSession
        isChatActive = true
        
        // 添加到会话列表
        chatSessions.insert(newSession, at: 0)
        saveChatSessions()
    }
    
    func continueChat(session: AIChatSession) {
        currentSession = session
        isChatActive = true
    }
    
    func closeChat() {
        isChatActive = false
        currentSession = nil
    }
    
    // MARK: - 消息管理
    
    func sendMessage(_ content: String) {
        guard let session = currentSession, !content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }
        
        let userMessage = AIChatMessage(
            content: content,
            isUser: true,
            timestamp: Date(),
            aiService: session.aiService
        )
        
        // 添加用户消息
        var updatedMessages = session.messages
        updatedMessages.append(userMessage)
        
        // 创建空的AI回复消息（用于流式更新）
        let aiReply = AIChatMessage(
            content: "",
            isUser: false,
            timestamp: Date(),
            aiService: session.aiService,
            isStreaming: true
        )
        
        updatedMessages.append(aiReply)
        
        // 更新会话
        let updatedSession = AIChatSession(
            id: session.id,
            aiService: session.aiService,
            title: session.title,
            messages: updatedMessages,
            createdAt: session.createdAt,
            lastUpdated: Date()
        )
        
        currentSession = updatedSession
        
        // 更新会话列表
        if let index = chatSessions.firstIndex(where: { $0.id == session.id }) {
            chatSessions[index] = updatedSession
        }
        
        saveChatSessions()
        
        // 异步调用AI API（避免阻塞UI）
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            self?.callAIAPI(message: content, aiService: session.aiService)
        }
    }
    
    // MARK: - AI API调用
    
    private func callAIAPI(message: String, aiService: String) {
        DispatchQueue.main.async {
            self.isLoading = true
        }
        
        // 根据AI服务调用相应API
        switch aiService {
        case "deepseek":
            callDeepSeekAPI(message: message)
        case "kimi":
            callKimiAPI(message: message)
        case "doubao":
            callDoubaoAPI(message: message)
        case "wenxin":
            callWenxinAPI(message: message)
        case "yuanbao":
            callYuanbaoAPI(message: message)
        case "chatglm":
            callChatGLMAPI(message: message)
        case "tongyi":
            callTongyiAPI(message: message)
        case "claude":
            callClaudeAPI(message: message)
        case "chatgpt":
            callChatGPTAPI(message: message)
        default:
            DispatchQueue.main.async {
                self.updateAIResponse(content: "暂不支持的AI服务：\(aiService)", isStreaming: false)
                self.isLoading = false
            }
        }
    }
    
    // MARK: - DeepSeek API调用
    
    private func callDeepSeekAPI(message: String) {
        // 检查是否有API密钥配置
        guard let apiKey = getAPIKey(for: "deepseek"), !apiKey.isEmpty else {
            DispatchQueue.main.async {
                self.updateAIResponse(content: "❌ 未配置DeepSeek API密钥\n\n请按以下步骤配置：\n1. 访问 https://platform.deepseek.com\n2. 获取API密钥\n3. 在设置中配置API密钥", isStreaming: false)
                self.isLoading = false
            }
            return
        }
        
        guard let url = URL(string: "https://api.deepseek.com/v1/chat/completions") else {
            DispatchQueue.main.async {
                self.updateAIResponse(content: "❌ API端点配置错误", isStreaming: false)
                self.isLoading = false
            }
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.timeoutInterval = 30.0
        
        let requestBody: [String: Any] = [
            "model": "deepseek-chat",
            "messages": [
                ["role": "user", "content": message]
            ],
            "max_tokens": 2000,
            "temperature": 0.7,
            "stream": false // 先使用非流式，后续可以改为流式
        ]
        
        do {
            request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
        } catch {
            DispatchQueue.main.async {
                self.updateAIResponse(content: "❌ 请求编码失败: \(error.localizedDescription)", isStreaming: false)
                self.isLoading = false
            }
            return
        }
        
        URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            DispatchQueue.main.async {
                self?.isLoading = false
                
                if let error = error {
                    self?.updateAIResponse(content: "❌ 网络错误: \(error.localizedDescription)", isStreaming: false)
                    return
                }
                
                guard let httpResponse = response as? HTTPURLResponse else {
                    self?.updateAIResponse(content: "❌ 无效的HTTP响应", isStreaming: false)
                    return
                }
                
                if httpResponse.statusCode != 200 {
                    self?.updateAIResponse(content: "❌ API调用失败，状态码: \(httpResponse.statusCode)", isStreaming: false)
                    return
                }
                
                guard let data = data else {
                    self?.updateAIResponse(content: "❌ 未收到响应数据", isStreaming: false)
                    return
                }
                
                self?.parseDeepSeekResponse(data: data)
            }
        }.resume()
    }
    
    private func parseDeepSeekResponse(data: Data) {
        do {
            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                updateAIResponse(content: "❌ 响应格式错误", isStreaming: false)
                return
            }
            
            // 检查API错误
            if let error = json["error"] as? [String: Any] {
                let errorMessage = error["message"] as? String ?? "未知错误"
                updateAIResponse(content: "❌ DeepSeek API错误: \(errorMessage)", isStreaming: false)
                return
            }
            
            // 提取AI回复
            guard let choices = json["choices"] as? [[String: Any]],
                  let firstChoice = choices.first,
                  let message = firstChoice["message"] as? [String: Any],
                  let content = message["content"] as? String else {
                updateAIResponse(content: "❌ 响应格式错误，无法提取AI回复内容", isStreaming: false)
                return
            }
            
            let aiContent = content.trimmingCharacters(in: .whitespacesAndNewlines)
            updateAIResponse(content: aiContent, isStreaming: false)
            
        } catch {
            updateAIResponse(content: "❌ 响应解析失败: \(error.localizedDescription)", isStreaming: false)
        }
    }
    
    // MARK: - 其他AI服务API调用（占位符）
    
    private func callKimiAPI(message: String) {
        updateAIResponse(content: "Kimi API暂未实现，请稍后...", isStreaming: false)
    }
    
    private func callDoubaoAPI(message: String) {
        updateAIResponse(content: "豆包 API暂未实现，请稍后...", isStreaming: false)
    }
    
    private func callWenxinAPI(message: String) {
        updateAIResponse(content: "文心一言 API暂未实现，请稍后...", isStreaming: false)
    }
    
    private func callYuanbaoAPI(message: String) {
        updateAIResponse(content: "元宝 API暂未实现，请稍后...", isStreaming: false)
    }
    
    private func callChatGLMAPI(message: String) {
        updateAIResponse(content: "智谱清言 API暂未实现，请稍后...", isStreaming: false)
    }
    
    private func callTongyiAPI(message: String) {
        updateAIResponse(content: "通义千问 API暂未实现，请稍后...", isStreaming: false)
    }
    
    private func callClaudeAPI(message: String) {
        updateAIResponse(content: "Claude API暂未实现，请稍后...", isStreaming: false)
    }
    
    private func callChatGPTAPI(message: String) {
        updateAIResponse(content: "ChatGPT API暂未实现，请稍后...", isStreaming: false)
    }
    
    // MARK: - AI响应更新
    
    private func updateAIResponse(content: String, isStreaming: Bool) {
        guard let session = currentSession else { return }
        
        // 更新最后一条AI消息
        var updatedMessages = session.messages
        if let lastIndex = updatedMessages.lastIndex(where: { !$0.isUser }) {
            updatedMessages[lastIndex] = AIChatMessage(
                id: updatedMessages[lastIndex].id,
                content: content,
                isUser: false,
                timestamp: updatedMessages[lastIndex].timestamp,
                aiService: updatedMessages[lastIndex].aiService,
                isStreaming: isStreaming
            )
        }
        
        // 更新会话
        let updatedSession = AIChatSession(
            id: session.id,
            aiService: session.aiService,
            title: session.title,
            messages: updatedMessages,
            createdAt: session.createdAt,
            lastUpdated: Date()
        )
        
        currentSession = updatedSession
        
        // 更新会话列表
        if let index = chatSessions.firstIndex(where: { $0.id == session.id }) {
            chatSessions[index] = updatedSession
        }
        
        saveChatSessions()
    }
    
    // MARK: - API密钥管理
    
    private func getAPIKey(for service: String) -> String? {
        return userDefaults.string(forKey: "\(service)_API_KEY")
    }
    
    func deleteSession(_ session: AIChatSession) {
        chatSessions.removeAll { $0.id == session.id }
        saveChatSessions()
    }
    
    // MARK: - 数据持久化
    
    private func saveChatSessions() {
        if let data = try? JSONEncoder().encode(chatSessions) {
            userDefaults.set(data, forKey: chatSessionsKey)
            userDefaults.synchronize()
        }
    }
    
    private func loadChatSessions() {
        if let data = userDefaults.data(forKey: chatSessionsKey),
           let sessions = try? JSONDecoder().decode([AIChatSession].self, from: data) {
            chatSessions = sessions
        }
    }
    
    // MARK: - 会话统计
    
    func getSessionCount(for aiService: String) -> Int {
        return chatSessions.filter { $0.aiService == aiService }.count
    }
    
    func getRecentSessions(for aiService: String, limit: Int = 5) -> [AIChatSession] {
        return chatSessions
            .filter { $0.aiService == aiService }
            .sorted { $0.lastUpdated > $1.lastUpdated }
            .prefix(limit)
            .map { $0 }
    }
} 